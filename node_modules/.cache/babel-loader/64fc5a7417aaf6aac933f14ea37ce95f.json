{"ast":null,"code":"var _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar Proto = require('uberproto'); // Returns a hook that emits service events. Should always be\n// used as the very last hook in the chain\n\n\nvar eventHook = exports.eventHook = function eventHook() {\n  return function (hook) {\n    var app = hook.app,\n        service = hook.service;\n    var eventName = hook.event === null ? hook.event : app.eventMappings[hook.method];\n    var isHookEvent = service._hookEvents && service._hookEvents.indexOf(eventName) !== -1; // If this event is not being sent yet and we are not in an error hook\n\n    if (eventName && isHookEvent && hook.type !== 'error') {\n      var results = Array.isArray(hook.result) ? hook.result : [hook.result];\n      results.forEach(function (element) {\n        return service.emit(eventName, element, hook);\n      });\n    }\n  };\n}; // Mixin that turns a service into a Node event emitter\n\n\nvar eventMixin = exports.eventMixin = function eventMixin(service) {\n  if (service._serviceEvents) {\n    return;\n  }\n\n  var app = this; // Indicates if the service is already an event emitter\n\n  var isEmitter = typeof service.on === 'function' && typeof service.emit === 'function'; // If not, mix it in (the service is always an Uberproto object that has a .mixin)\n\n  if (typeof service.mixin === 'function' && !isEmitter) {\n    service.mixin(EventEmitter.prototype);\n  } // Define non-enumerable properties of\n\n\n  Object.defineProperties(service, {\n    // A list of all events that this service sends\n    _serviceEvents: {\n      value: Array.isArray(service.events) ? service.events.slice() : []\n    },\n    // A list of events that should be handled through the event hooks\n    _hookEvents: {\n      value: []\n    }\n  }); // `app.eventMappings` has the mapping from method name to event name\n\n  Object.keys(app.eventMappings).forEach(function (method) {\n    var event = app.eventMappings[method];\n    var alreadyEmits = service._serviceEvents.indexOf(event) !== -1; // Add events for known methods to _serviceEvents and _hookEvents\n    // if the service indicated it does not send it itself yet\n\n    if (typeof service[method] === 'function' && !alreadyEmits) {\n      service._serviceEvents.push(event);\n\n      service._hookEvents.push(event);\n    }\n  });\n};\n\nmodule.exports = function () {\n  return function (app) {\n    // Mappings from service method to event name\n    Object.assign(app, {\n      eventMappings: {\n        create: 'created',\n        update: 'updated',\n        remove: 'removed',\n        patch: 'patched'\n      }\n    }); // Register the event hook\n    // `finally` hooks always run last after `error` and `after` hooks\n\n    app.hooks({\n      finally: eventHook()\n    }); // Make the app an event emitter\n\n    Proto.mixin(EventEmitter.prototype, app);\n    app.mixins.push(eventMixin);\n  };\n};","map":{"version":3,"sources":["/home/mfybaby/Documents/HealthStack2/HS-frontend/node_modules/@feathersjs/feathers/lib/events.js"],"names":["require","EventEmitter","Proto","eventHook","exports","hook","app","service","eventName","event","eventMappings","method","isHookEvent","_hookEvents","indexOf","type","results","Array","isArray","result","forEach","element","emit","eventMixin","_serviceEvents","isEmitter","on","mixin","prototype","Object","defineProperties","value","events","slice","keys","alreadyEmits","push","module","assign","create","update","remove","patch","hooks","finally","mixins"],"mappings":"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","sourcesContent":["const { EventEmitter } = require('events');\nconst Proto = require('uberproto');\n\n// Returns a hook that emits service events. Should always be\n// used as the very last hook in the chain\nconst eventHook = exports.eventHook = function eventHook () {\n  return function (hook) {\n    const { app, service } = hook;\n    const eventName = hook.event === null ? hook.event : app.eventMappings[hook.method];\n    const isHookEvent = service._hookEvents && service._hookEvents.indexOf(eventName) !== -1;\n\n    // If this event is not being sent yet and we are not in an error hook\n    if (eventName && isHookEvent && hook.type !== 'error') {\n      const results = Array.isArray(hook.result) ? hook.result : [ hook.result ];\n\n      results.forEach(element => service.emit(eventName, element, hook));\n    }\n  };\n};\n\n// Mixin that turns a service into a Node event emitter\nconst eventMixin = exports.eventMixin = function eventMixin (service) {\n  if (service._serviceEvents) {\n    return;\n  }\n\n  const app = this;\n  // Indicates if the service is already an event emitter\n  const isEmitter = typeof service.on === 'function' &&\n    typeof service.emit === 'function';\n\n  // If not, mix it in (the service is always an Uberproto object that has a .mixin)\n  if (typeof service.mixin === 'function' && !isEmitter) {\n    service.mixin(EventEmitter.prototype);\n  }\n\n  // Define non-enumerable properties of\n  Object.defineProperties(service, {\n    // A list of all events that this service sends\n    _serviceEvents: {\n      value: Array.isArray(service.events) ? service.events.slice() : []\n    },\n\n    // A list of events that should be handled through the event hooks\n    _hookEvents: {\n      value: []\n    }\n  });\n\n  // `app.eventMappings` has the mapping from method name to event name\n  Object.keys(app.eventMappings).forEach(method => {\n    const event = app.eventMappings[method];\n    const alreadyEmits = service._serviceEvents.indexOf(event) !== -1;\n\n    // Add events for known methods to _serviceEvents and _hookEvents\n    // if the service indicated it does not send it itself yet\n    if (typeof service[method] === 'function' && !alreadyEmits) {\n      service._serviceEvents.push(event);\n      service._hookEvents.push(event);\n    }\n  });\n};\n\nmodule.exports = function () {\n  return function (app) {\n    // Mappings from service method to event name\n    Object.assign(app, {\n      eventMappings: {\n        create: 'created',\n        update: 'updated',\n        remove: 'removed',\n        patch: 'patched'\n      }\n    });\n\n    // Register the event hook\n    // `finally` hooks always run last after `error` and `after` hooks\n    app.hooks({ finally: eventHook() });\n\n    // Make the app an event emitter\n    Proto.mixin(EventEmitter.prototype, app);\n\n    app.mixins.push(eventMixin);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableHooks = exports.processHooks = exports.getHooks = exports.isHookObject = exports.convertHookData = exports.makeArguments = exports.defaultMakeArguments = exports.createHookObject = exports.ACTIVATE_HOOKS = void 0;\n\nvar utils_1 = require(\"./utils\");\n\nvar _utils_1$_ = utils_1._,\n    each = _utils_1$_.each,\n    pick = _utils_1$_.pick;\nexports.ACTIVATE_HOOKS = utils_1.createSymbol('__feathersActivateHooks');\n\nfunction createHookObject(method) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var hook = {};\n  Object.defineProperty(hook, 'toJSON', {\n    value: function value() {\n      return pick(this, 'type', 'method', 'path', 'params', 'id', 'data', 'result', 'error');\n    }\n  });\n  return Object.assign(hook, data, {\n    method: method,\n\n    // A dynamic getter that returns the path of the service\n    get path() {\n      var app = data.app,\n          service = data.service;\n\n      if (!service || !app || !app.services) {\n        return null;\n      }\n\n      return Object.keys(app.services).find(function (path) {\n        return app.services[path] === service;\n      });\n    }\n\n  });\n}\n\nexports.createHookObject = createHookObject; // Fallback used by `makeArguments` which usually won't be used\n\nfunction defaultMakeArguments(hook) {\n  var result = [];\n\n  if (typeof hook.id !== 'undefined') {\n    result.push(hook.id);\n  }\n\n  if (hook.data) {\n    result.push(hook.data);\n  }\n\n  result.push(hook.params || {});\n  return result;\n}\n\nexports.defaultMakeArguments = defaultMakeArguments; // Turns a hook object back into a list of arguments\n// to call a service method with\n\nfunction makeArguments(hook) {\n  switch (hook.method) {\n    case 'find':\n      return [hook.params];\n\n    case 'get':\n    case 'remove':\n      return [hook.id, hook.params];\n\n    case 'update':\n    case 'patch':\n      return [hook.id, hook.data, hook.params];\n\n    case 'create':\n      return [hook.data, hook.params];\n  }\n\n  return defaultMakeArguments(hook);\n}\n\nexports.makeArguments = makeArguments; // Converts different hook registration formats into the\n// same internal format\n\nfunction convertHookData(obj) {\n  var hook = {};\n\n  if (Array.isArray(obj)) {\n    hook = {\n      all: obj\n    };\n  } else if (typeof obj !== 'object') {\n    hook = {\n      all: [obj]\n    };\n  } else {\n    each(obj, function (value, key) {\n      hook[key] = !Array.isArray(value) ? [value] : value;\n    });\n  }\n\n  return hook;\n}\n\nexports.convertHookData = convertHookData; // Duck-checks a given object to be a hook object\n// A valid hook object has `type` and `method`\n\nfunction isHookObject(hookObject) {\n  return typeof hookObject === 'object' && typeof hookObject.method === 'string' && typeof hookObject.type === 'string';\n}\n\nexports.isHookObject = isHookObject; // Returns all service and application hooks combined\n// for a given method and type `appLast` sets if the hooks\n// from `app` should be added last (or first by default)\n\nfunction getHooks(app, service, type, method) {\n  var appLast = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var appHooks = app.__hooks[type][method] || [];\n  var serviceHooks = service.__hooks[type][method] || [];\n\n  if (appLast) {\n    // Run hooks in the order of service -> app -> finally\n    return serviceHooks.concat(appHooks);\n  }\n\n  return appHooks.concat(serviceHooks);\n}\n\nexports.getHooks = getHooks;\n\nfunction processHooks(hooks, initialHookObject) {\n  var _this = this;\n\n  var hookObject = initialHookObject;\n\n  var updateCurrentHook = function updateCurrentHook(current) {\n    // Either use the returned hook object or the current\n    // hook object from the chain if the hook returned undefined\n    if (current) {\n      if (!isHookObject(current)) {\n        throw new Error(\"\".concat(hookObject.type, \" hook for '\").concat(hookObject.method, \"' method returned invalid hook object\"));\n      }\n\n      hookObject = current;\n    }\n\n    return hookObject;\n  }; // Go through all hooks and chain them into our promise\n\n\n  var promise = hooks.reduce(function (current, fn) {\n    // @ts-ignore\n    var hook = fn.bind(_this); // Use the returned hook object or the old one\n\n    return current.then(function (currentHook) {\n      return hook(currentHook);\n    }).then(updateCurrentHook);\n  }, Promise.resolve(hookObject));\n  return promise.then(function () {\n    return hookObject;\n  }).catch(function (error) {\n    // Add the hook information to any errors\n    error.hook = hookObject;\n    throw error;\n  });\n}\n\nexports.processHooks = processHooks; // Add `.hooks` functionality to an object\n\nfunction enableHooks(obj, methods, types) {\n  if (typeof obj.hooks === 'function') {\n    return obj;\n  }\n\n  var hookData = {};\n  types.forEach(function (type) {\n    // Initialize properties where hook functions are stored\n    hookData[type] = {};\n  }); // Add non-enumerable `__hooks` property to the object\n\n  Object.defineProperty(obj, '__hooks', {\n    configurable: true,\n    value: hookData,\n    writable: true\n  });\n  return Object.assign(obj, {\n    hooks: function hooks(allHooks) {\n      var _this2 = this;\n\n      each(allHooks, function (current, type) {\n        // @ts-ignore\n        if (!_this2.__hooks[type]) {\n          throw new Error(\"'\".concat(type, \"' is not a valid hook type\"));\n        }\n\n        var hooks = convertHookData(current);\n        each(hooks, function (_value, method) {\n          if (method !== 'all' && methods.indexOf(method) === -1) {\n            throw new Error(\"'\".concat(method, \"' is not a valid hook method\"));\n          }\n        });\n        methods.forEach(function (method) {\n          // @ts-ignore\n          var myHooks = _this2.__hooks[type][method] || (_this2.__hooks[type][method] = []);\n\n          if (hooks.all) {\n            myHooks.push.apply(myHooks, hooks.all);\n          }\n\n          if (hooks[method]) {\n            myHooks.push.apply(myHooks, hooks[method]);\n          }\n        });\n      });\n      return this;\n    }\n  });\n}\n\nexports.enableHooks = enableHooks;","map":{"version":3,"sources":["../src/hooks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.enableHooks = exports.processHooks = exports.getHooks = exports.isHookObject = exports.convertHookData = exports.makeArguments = exports.defaultMakeArguments = exports.createHookObject = exports.ACTIVATE_HOOKS = void 0;\nconst utils_1 = require(\"./utils\");\nconst { each, pick } = utils_1._;\nexports.ACTIVATE_HOOKS = utils_1.createSymbol('__feathersActivateHooks');\nfunction createHookObject(method, data = {}) {\n    const hook = {};\n    Object.defineProperty(hook, 'toJSON', {\n        value() {\n            return pick(this, 'type', 'method', 'path', 'params', 'id', 'data', 'result', 'error');\n        }\n    });\n    return Object.assign(hook, data, {\n        method,\n        // A dynamic getter that returns the path of the service\n        get path() {\n            const { app, service } = data;\n            if (!service || !app || !app.services) {\n                return null;\n            }\n            return Object.keys(app.services)\n                .find(path => app.services[path] === service);\n        }\n    });\n}\nexports.createHookObject = createHookObject;\n// Fallback used by `makeArguments` which usually won't be used\nfunction defaultMakeArguments(hook) {\n    const result = [];\n    if (typeof hook.id !== 'undefined') {\n        result.push(hook.id);\n    }\n    if (hook.data) {\n        result.push(hook.data);\n    }\n    result.push(hook.params || {});\n    return result;\n}\nexports.defaultMakeArguments = defaultMakeArguments;\n// Turns a hook object back into a list of arguments\n// to call a service method with\nfunction makeArguments(hook) {\n    switch (hook.method) {\n        case 'find':\n            return [hook.params];\n        case 'get':\n        case 'remove':\n            return [hook.id, hook.params];\n        case 'update':\n        case 'patch':\n            return [hook.id, hook.data, hook.params];\n        case 'create':\n            return [hook.data, hook.params];\n    }\n    return defaultMakeArguments(hook);\n}\nexports.makeArguments = makeArguments;\n// Converts different hook registration formats into the\n// same internal format\nfunction convertHookData(obj) {\n    let hook = {};\n    if (Array.isArray(obj)) {\n        hook = { all: obj };\n    }\n    else if (typeof obj !== 'object') {\n        hook = { all: [obj] };\n    }\n    else {\n        each(obj, function (value, key) {\n            hook[key] = !Array.isArray(value) ? [value] : value;\n        });\n    }\n    return hook;\n}\nexports.convertHookData = convertHookData;\n// Duck-checks a given object to be a hook object\n// A valid hook object has `type` and `method`\nfunction isHookObject(hookObject) {\n    return typeof hookObject === 'object' &&\n        typeof hookObject.method === 'string' &&\n        typeof hookObject.type === 'string';\n}\nexports.isHookObject = isHookObject;\n// Returns all service and application hooks combined\n// for a given method and type `appLast` sets if the hooks\n// from `app` should be added last (or first by default)\nfunction getHooks(app, service, type, method, appLast = false) {\n    const appHooks = app.__hooks[type][method] || [];\n    const serviceHooks = service.__hooks[type][method] || [];\n    if (appLast) {\n        // Run hooks in the order of service -> app -> finally\n        return serviceHooks.concat(appHooks);\n    }\n    return appHooks.concat(serviceHooks);\n}\nexports.getHooks = getHooks;\nfunction processHooks(hooks, initialHookObject) {\n    let hookObject = initialHookObject;\n    const updateCurrentHook = (current) => {\n        // Either use the returned hook object or the current\n        // hook object from the chain if the hook returned undefined\n        if (current) {\n            if (!isHookObject(current)) {\n                throw new Error(`${hookObject.type} hook for '${hookObject.method}' method returned invalid hook object`);\n            }\n            hookObject = current;\n        }\n        return hookObject;\n    };\n    // Go through all hooks and chain them into our promise\n    const promise = hooks.reduce((current, fn) => {\n        // @ts-ignore\n        const hook = fn.bind(this);\n        // Use the returned hook object or the old one\n        return current.then((currentHook) => hook(currentHook)).then(updateCurrentHook);\n    }, Promise.resolve(hookObject));\n    return promise.then(() => hookObject).catch(error => {\n        // Add the hook information to any errors\n        error.hook = hookObject;\n        throw error;\n    });\n}\nexports.processHooks = processHooks;\n// Add `.hooks` functionality to an object\nfunction enableHooks(obj, methods, types) {\n    if (typeof obj.hooks === 'function') {\n        return obj;\n    }\n    const hookData = {};\n    types.forEach(type => {\n        // Initialize properties where hook functions are stored\n        hookData[type] = {};\n    });\n    // Add non-enumerable `__hooks` property to the object\n    Object.defineProperty(obj, '__hooks', {\n        configurable: true,\n        value: hookData,\n        writable: true\n    });\n    return Object.assign(obj, {\n        hooks(allHooks) {\n            each(allHooks, (current, type) => {\n                // @ts-ignore\n                if (!this.__hooks[type]) {\n                    throw new Error(`'${type}' is not a valid hook type`);\n                }\n                const hooks = convertHookData(current);\n                each(hooks, (_value, method) => {\n                    if (method !== 'all' && methods.indexOf(method) === -1) {\n                        throw new Error(`'${method}' is not a valid hook method`);\n                    }\n                });\n                methods.forEach(method => {\n                    // @ts-ignore\n                    const myHooks = this.__hooks[type][method] || (this.__hooks[type][method] = []);\n                    if (hooks.all) {\n                        myHooks.push.apply(myHooks, hooks.all);\n                    }\n                    if (hooks[method]) {\n                        myHooks.push.apply(myHooks, hooks[method]);\n                    }\n                });\n            });\n            return this;\n        }\n    });\n}\nexports.enableHooks = enableHooks;\n//# sourceMappingURL=hooks.js.map"]},"metadata":{},"sourceType":"script"}
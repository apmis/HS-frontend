{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/mfybaby/Documents/HealthStack2/HS-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/mfybaby/Documents/HealthStack2/HS-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/home/mfybaby/Documents/HealthStack2/HS-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthenticationClient = void 0;\n\nvar errors_1 = require(\"@feathersjs/errors\");\n\nvar storage_1 = require(\"./storage\");\n\nvar getMatch = function getMatch(location, key) {\n  var regex = new RegExp(\"(?:&?)\".concat(key, \"=([^&]*)\"));\n  var match = location.hash ? location.hash.match(regex) : null;\n\n  if (match !== null) {\n    var _match = _slicedToArray(match, 2),\n        value = _match[1];\n\n    return [value, regex];\n  }\n\n  return [null, regex];\n};\n\nvar AuthenticationClient = /*#__PURE__*/function () {\n  function AuthenticationClient(app, options) {\n    _classCallCheck(this, AuthenticationClient);\n\n    var socket = app.io || app.primus;\n    var storage = new storage_1.StorageWrapper(app.get('storage') || options.storage);\n    this.app = app;\n    this.options = options;\n    this.authenticated = false;\n    this.app.set('storage', storage);\n\n    if (socket) {\n      this.handleSocket(socket);\n    }\n  }\n\n  _createClass(AuthenticationClient, [{\n    key: \"handleSocket\",\n    value: function handleSocket(socket) {\n      var _this = this;\n\n      // Connection events happen on every reconnect\n      var connected = this.app.io ? 'connect' : 'open';\n      var disconnected = this.app.io ? 'disconnect' : 'disconnection';\n      socket.on(disconnected, function () {\n        var authPromise = new Promise(function (resolve) {\n          return socket.once(connected, function (data) {\n            return resolve(data);\n          });\n        }) // Only reconnect when `reAuthenticate()` or `authenticate()`\n        // has been called explicitly first\n        // Force reauthentication with the server\n        .then(function () {\n          return _this.authenticated ? _this.reAuthenticate(true) : null;\n        });\n\n        _this.app.set('authentication', authPromise);\n      });\n    }\n  }, {\n    key: \"getFromLocation\",\n    value: function getFromLocation(location) {\n      var _getMatch = getMatch(location, this.options.locationKey),\n          _getMatch2 = _slicedToArray(_getMatch, 2),\n          accessToken = _getMatch2[0],\n          tokenRegex = _getMatch2[1];\n\n      if (accessToken !== null) {\n        location.hash = location.hash.replace(tokenRegex, '');\n        return Promise.resolve(accessToken);\n      }\n\n      var _getMatch3 = getMatch(location, this.options.locationErrorKey),\n          _getMatch4 = _slicedToArray(_getMatch3, 2),\n          message = _getMatch4[0],\n          errorRegex = _getMatch4[1];\n\n      if (message !== null) {\n        location.hash = location.hash.replace(errorRegex, '');\n        return Promise.reject(new errors_1.NotAuthenticated(decodeURIComponent(message)));\n      }\n\n      return Promise.resolve(null);\n    }\n  }, {\n    key: \"setAccessToken\",\n    value: function setAccessToken(accessToken) {\n      return this.storage.setItem(this.options.storageKey, accessToken);\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken() {\n      var _this2 = this;\n\n      return this.storage.getItem(this.options.storageKey).then(function (accessToken) {\n        if (!accessToken && typeof window !== 'undefined' && window.location) {\n          return _this2.getFromLocation(window.location);\n        }\n\n        return accessToken || null;\n      });\n    }\n  }, {\n    key: \"removeAccessToken\",\n    value: function removeAccessToken() {\n      return this.storage.removeItem(this.options.storageKey);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.app.set('authentication', null);\n      this.authenticated = false;\n      return Promise.resolve(null);\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, type) {\n      var _this3 = this;\n\n      if (error.code === 401 || error.code === 403) {\n        var promise = this.removeAccessToken().then(function () {\n          return _this3.reset();\n        });\n        return type === 'logout' ? promise : promise.then(function () {\n          return Promise.reject(error);\n        });\n      }\n\n      return Promise.reject(error);\n    }\n  }, {\n    key: \"reAuthenticate\",\n    value: function reAuthenticate() {\n      var _this4 = this;\n\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var strategy = arguments.length > 1 ? arguments[1] : undefined;\n      // Either returns the authentication state or\n      // tries to re-authenticate with the stored JWT and strategy\n      var authPromise = this.app.get('authentication');\n\n      if (!authPromise || force === true) {\n        return this.getAccessToken().then(function (accessToken) {\n          if (!accessToken) {\n            throw new errors_1.NotAuthenticated('No accessToken found in storage');\n          }\n\n          return _this4.authenticate({\n            strategy: strategy || _this4.options.jwtStrategy,\n            accessToken: accessToken\n          });\n        });\n      }\n\n      return authPromise;\n    }\n  }, {\n    key: \"authenticate\",\n    value: function authenticate(authentication, params) {\n      var _this5 = this;\n\n      if (!authentication) {\n        return this.reAuthenticate();\n      }\n\n      var promise = this.service.create(authentication, params).then(function (authResult) {\n        var accessToken = authResult.accessToken;\n        _this5.authenticated = true;\n\n        _this5.app.emit('login', authResult);\n\n        _this5.app.emit('authenticated', authResult);\n\n        return _this5.setAccessToken(accessToken).then(function () {\n          return authResult;\n        });\n      }).catch(function (error) {\n        return _this5.handleError(error, 'authenticate');\n      });\n      this.app.set('authentication', promise);\n      return promise;\n    }\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var _this6 = this;\n\n      return Promise.resolve(this.app.get('authentication')).then(function () {\n        return _this6.service.remove(null).then(function (authResult) {\n          return _this6.removeAccessToken().then(function () {\n            return _this6.reset();\n          }).then(function () {\n            _this6.app.emit('logout', authResult);\n\n            return authResult;\n          });\n        });\n      }).catch(function (error) {\n        return _this6.handleError(error, 'logout');\n      });\n    }\n  }, {\n    key: \"service\",\n    get: function get() {\n      return this.app.service(this.options.path);\n    }\n  }, {\n    key: \"storage\",\n    get: function get() {\n      return this.app.get('storage');\n    }\n  }]);\n\n  return AuthenticationClient;\n}();\n\nexports.AuthenticationClient = AuthenticationClient;","map":{"version":3,"sources":["../src/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AuthenticationClient = void 0;\nconst errors_1 = require(\"@feathersjs/errors\");\nconst storage_1 = require(\"./storage\");\nconst getMatch = (location, key) => {\n    const regex = new RegExp(`(?:\\&?)${key}=([^&]*)`);\n    const match = location.hash ? location.hash.match(regex) : null;\n    if (match !== null) {\n        const [, value] = match;\n        return [value, regex];\n    }\n    return [null, regex];\n};\nclass AuthenticationClient {\n    constructor(app, options) {\n        const socket = app.io || app.primus;\n        const storage = new storage_1.StorageWrapper(app.get('storage') || options.storage);\n        this.app = app;\n        this.options = options;\n        this.authenticated = false;\n        this.app.set('storage', storage);\n        if (socket) {\n            this.handleSocket(socket);\n        }\n    }\n    get service() {\n        return this.app.service(this.options.path);\n    }\n    get storage() {\n        return this.app.get('storage');\n    }\n    handleSocket(socket) {\n        // Connection events happen on every reconnect\n        const connected = this.app.io ? 'connect' : 'open';\n        const disconnected = this.app.io ? 'disconnect' : 'disconnection';\n        socket.on(disconnected, () => {\n            const authPromise = new Promise(resolve => socket.once(connected, (data) => resolve(data)))\n                // Only reconnect when `reAuthenticate()` or `authenticate()`\n                // has been called explicitly first\n                // Force reauthentication with the server\n                .then(() => this.authenticated ? this.reAuthenticate(true) : null);\n            this.app.set('authentication', authPromise);\n        });\n    }\n    getFromLocation(location) {\n        const [accessToken, tokenRegex] = getMatch(location, this.options.locationKey);\n        if (accessToken !== null) {\n            location.hash = location.hash.replace(tokenRegex, '');\n            return Promise.resolve(accessToken);\n        }\n        const [message, errorRegex] = getMatch(location, this.options.locationErrorKey);\n        if (message !== null) {\n            location.hash = location.hash.replace(errorRegex, '');\n            return Promise.reject(new errors_1.NotAuthenticated(decodeURIComponent(message)));\n        }\n        return Promise.resolve(null);\n    }\n    setAccessToken(accessToken) {\n        return this.storage.setItem(this.options.storageKey, accessToken);\n    }\n    getAccessToken() {\n        return this.storage.getItem(this.options.storageKey)\n            .then((accessToken) => {\n            if (!accessToken && typeof window !== 'undefined' && window.location) {\n                return this.getFromLocation(window.location);\n            }\n            return accessToken || null;\n        });\n    }\n    removeAccessToken() {\n        return this.storage.removeItem(this.options.storageKey);\n    }\n    reset() {\n        this.app.set('authentication', null);\n        this.authenticated = false;\n        return Promise.resolve(null);\n    }\n    handleError(error, type) {\n        if (error.code === 401 || error.code === 403) {\n            const promise = this.removeAccessToken().then(() => this.reset());\n            return type === 'logout' ? promise : promise.then(() => Promise.reject(error));\n        }\n        return Promise.reject(error);\n    }\n    reAuthenticate(force = false, strategy) {\n        // Either returns the authentication state or\n        // tries to re-authenticate with the stored JWT and strategy\n        const authPromise = this.app.get('authentication');\n        if (!authPromise || force === true) {\n            return this.getAccessToken().then(accessToken => {\n                if (!accessToken) {\n                    throw new errors_1.NotAuthenticated('No accessToken found in storage');\n                }\n                return this.authenticate({\n                    strategy: strategy || this.options.jwtStrategy,\n                    accessToken\n                });\n            });\n        }\n        return authPromise;\n    }\n    authenticate(authentication, params) {\n        if (!authentication) {\n            return this.reAuthenticate();\n        }\n        const promise = this.service.create(authentication, params)\n            .then((authResult) => {\n            const { accessToken } = authResult;\n            this.authenticated = true;\n            this.app.emit('login', authResult);\n            this.app.emit('authenticated', authResult);\n            return this.setAccessToken(accessToken).then(() => authResult);\n        }).catch((error) => this.handleError(error, 'authenticate'));\n        this.app.set('authentication', promise);\n        return promise;\n    }\n    logout() {\n        return Promise.resolve(this.app.get('authentication'))\n            .then(() => this.service.remove(null)\n            .then((authResult) => this.removeAccessToken()\n            .then(() => this.reset())\n            .then(() => {\n            this.app.emit('logout', authResult);\n            return authResult;\n        })))\n            .catch((error) => this.handleError(error, 'logout'));\n    }\n}\nexports.AuthenticationClient = AuthenticationClient;\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}
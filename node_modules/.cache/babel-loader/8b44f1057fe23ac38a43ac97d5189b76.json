{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/mfybaby/Documents/HealthStack2/HS-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/mfybaby/Documents/HealthStack2/HS-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Service = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar errors_1 = require(\"@feathersjs/errors\");\n\nvar debug = debug_1.default('@feathersjs/transport-commons/client');\nvar namespacedEmitterMethods = ['addListener', 'emit', 'listenerCount', 'listeners', 'on', 'once', 'prependListener', 'prependOnceListener', 'removeAllListeners', 'removeListener'];\nvar otherEmitterMethods = ['eventNames', 'getMaxListeners', 'setMaxListeners'];\n\nvar addEmitterMethods = function addEmitterMethods(service) {\n  otherEmitterMethods.forEach(function (method) {\n    service[method] = function () {\n      var _this$connection;\n\n      if (typeof this.connection[method] !== 'function') {\n        throw new Error(\"Can not call '\".concat(method, \"' on the client service connection\"));\n      }\n\n      return (_this$connection = this.connection)[method].apply(_this$connection, arguments);\n    };\n  }); // Methods that should add the namespace (service path)\n\n  namespacedEmitterMethods.forEach(function (method) {\n    service[method] = function (name) {\n      var _this$connection2;\n\n      if (typeof this.connection[method] !== 'function') {\n        throw new Error(\"Can not call '\".concat(method, \"' on the client service connection\"));\n      }\n\n      var eventName = \"\".concat(this.path, \" \").concat(name);\n      debug(\"Calling emitter method \".concat(method, \" with \") + \"namespaced event '\".concat(eventName, \"'\"));\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var result = (_this$connection2 = this.connection)[method].apply(_this$connection2, [eventName].concat(args));\n\n      return result === this.connection ? this : result;\n    };\n  });\n};\n\nvar Service = /*#__PURE__*/function () {\n  function Service(options) {\n    _classCallCheck(this, Service);\n\n    this.events = options.events;\n    this.path = options.name;\n    this.connection = options.connection;\n    this.method = options.method;\n    this.timeout = options.timeout || 5000;\n    addEmitterMethods(this);\n  }\n\n  _createClass(Service, [{\n    key: \"send\",\n    value: function send(method) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return new Promise(function (resolve, reject) {\n        var _this$connection3;\n\n        var timeoutId = setTimeout(function () {\n          return reject(new errors_1.Timeout(\"Timeout of \".concat(_this.timeout, \"ms exceeded calling \").concat(method, \" on \").concat(_this.path), {\n            timeout: _this.timeout,\n            method: method,\n            path: _this.path\n          }));\n        }, _this.timeout);\n        args.unshift(method, _this.path);\n        args.push(function (error, data) {\n          error = errors_1.convert(error);\n          clearTimeout(timeoutId);\n          return error ? reject(error) : resolve(data);\n        });\n        debug(\"Sending socket.\".concat(_this.method), args);\n\n        (_this$connection3 = _this.connection)[_this.method].apply(_this$connection3, args);\n      });\n    }\n  }, {\n    key: \"find\",\n    value: function find() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.send('find', params.query || {});\n    }\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.send('get', id, params.query || {});\n    }\n  }, {\n    key: \"create\",\n    value: function create(data) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.send('create', data, params.query || {});\n    }\n  }, {\n    key: \"update\",\n    value: function update(id, data) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.send('update', id, data, params.query || {});\n    }\n  }, {\n    key: \"patch\",\n    value: function patch(id, data) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.send('patch', id, data, params.query || {});\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.send('remove', id, params.query || {});\n    } // `off` is actually not part of the Node event emitter spec\n    // but we are adding it since everybody is expecting it because\n    // of the emitter-component Socket.io is using\n\n  }, {\n    key: \"off\",\n    value: function off(name) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      if (typeof this.connection.off === 'function') {\n        var _this$connection4;\n\n        var result = (_this$connection4 = this.connection).off.apply(_this$connection4, [\"\".concat(this.path, \" \").concat(name)].concat(args));\n\n        return result === this.connection ? this : result;\n      } else if (args.length === 0) {\n        // @ts-ignore\n        return this.removeAllListeners(name);\n      } // @ts-ignore\n\n\n      return this.removeListener.apply(this, [name].concat(args));\n    }\n  }]);\n\n  return Service;\n}();\n\nexports.Service = Service;","map":{"version":3,"sources":["../src/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Service = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst errors_1 = require(\"@feathersjs/errors\");\nconst debug = debug_1.default('@feathersjs/transport-commons/client');\nconst namespacedEmitterMethods = [\n    'addListener',\n    'emit',\n    'listenerCount',\n    'listeners',\n    'on',\n    'once',\n    'prependListener',\n    'prependOnceListener',\n    'removeAllListeners',\n    'removeListener'\n];\nconst otherEmitterMethods = [\n    'eventNames',\n    'getMaxListeners',\n    'setMaxListeners'\n];\nconst addEmitterMethods = (service) => {\n    otherEmitterMethods.forEach(method => {\n        service[method] = function (...args) {\n            if (typeof this.connection[method] !== 'function') {\n                throw new Error(`Can not call '${method}' on the client service connection`);\n            }\n            return this.connection[method](...args);\n        };\n    });\n    // Methods that should add the namespace (service path)\n    namespacedEmitterMethods.forEach(method => {\n        service[method] = function (name, ...args) {\n            if (typeof this.connection[method] !== 'function') {\n                throw new Error(`Can not call '${method}' on the client service connection`);\n            }\n            const eventName = `${this.path} ${name}`;\n            debug(`Calling emitter method ${method} with ` +\n                `namespaced event '${eventName}'`);\n            const result = this.connection[method](eventName, ...args);\n            return result === this.connection ? this : result;\n        };\n    });\n};\nclass Service {\n    constructor(options) {\n        this.events = options.events;\n        this.path = options.name;\n        this.connection = options.connection;\n        this.method = options.method;\n        this.timeout = options.timeout || 5000;\n        addEmitterMethods(this);\n    }\n    send(method, ...args) {\n        return new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => reject(new errors_1.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${method} on ${this.path}`, {\n                timeout: this.timeout,\n                method,\n                path: this.path\n            })), this.timeout);\n            args.unshift(method, this.path);\n            args.push(function (error, data) {\n                error = errors_1.convert(error);\n                clearTimeout(timeoutId);\n                return error ? reject(error) : resolve(data);\n            });\n            debug(`Sending socket.${this.method}`, args);\n            this.connection[this.method](...args);\n        });\n    }\n    find(params = {}) {\n        return this.send('find', params.query || {});\n    }\n    get(id, params = {}) {\n        return this.send('get', id, params.query || {});\n    }\n    create(data, params = {}) {\n        return this.send('create', data, params.query || {});\n    }\n    update(id, data, params = {}) {\n        return this.send('update', id, data, params.query || {});\n    }\n    patch(id, data, params = {}) {\n        return this.send('patch', id, data, params.query || {});\n    }\n    remove(id, params = {}) {\n        return this.send('remove', id, params.query || {});\n    }\n    // `off` is actually not part of the Node event emitter spec\n    // but we are adding it since everybody is expecting it because\n    // of the emitter-component Socket.io is using\n    off(name, ...args) {\n        if (typeof this.connection.off === 'function') {\n            const result = this.connection.off(`${this.path} ${name}`, ...args);\n            return result === this.connection ? this : result;\n        }\n        else if (args.length === 0) {\n            // @ts-ignore\n            return this.removeAllListeners(name);\n        }\n        // @ts-ignore\n        return this.removeListener(name, ...args);\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}
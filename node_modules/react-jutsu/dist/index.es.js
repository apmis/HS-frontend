import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var useJitsi = function useJitsi(_ref) {
  var _ref$domain = _ref.domain,
      domain = _ref$domain === undefined ? 'meet.jit.si' : _ref$domain,
      parentNode = _ref.parentNode,
      subject = _ref.subject,
      password = _ref.password,
      displayName = _ref.displayName,
      onMeetingEnd = _ref.onMeetingEnd,
      options = objectWithoutProperties(_ref, ['domain', 'parentNode', 'subject', 'password', 'displayName', 'onMeetingEnd']);

  var _useState = useState(true),
      _useState2 = slicedToArray(_useState, 2),
      loading = _useState2[0],
      setLoading = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = slicedToArray(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var _useState5 = useState(null),
      _useState6 = slicedToArray(_useState5, 2),
      jitsi = _useState6[0],
      setJitsi = _useState6[1];

  useEffect(function () {
    if (!window.JitsiMeetExternalAPI) {
      setError('JitsiMeetExternalAPI is not available, check if https://meet.jit.si/external_api.js was loaded');
      return;
    }

    options.parentNode = document.getElementById(parentNode);
    if (!options.parentNode) {
      setError('Parent node is not available, check container have the correct id: "' + parentNode + '"');
      return;
    }

    var client = new window.JitsiMeetExternalAPI(domain, _extends({}, options));
    setJitsi(client);
    setLoading(false);
    setError(null);

    subject && client.executeCommand('subject', subject);

    client.addEventListener('videoConferenceJoined', function () {
      password && client.executeCommand('password', password);
      displayName && client.executeCommand('displayName', displayName);
    });

    client.addEventListener('passwordRequired', function () {
      password && client.executeCommand('password', password);
    });
    onMeetingEnd && client.addEventListener('readyToClose', onMeetingEnd);

    return function () {
      return jitsi && jitsi.dispose();
    };
  }, [window.JitsiMeetExternalAPI]);

  return { jitsi: jitsi, error: error, loading: loading };
};

useJitsi.propTypes = {
  options: PropTypes.shape({
    domain: PropTypes.string,
    roomName: PropTypes.string.isRequired,
    subject: PropTypes.string,
    password: PropTypes.string,
    displayName: PropTypes.string,
    onMeetingEnd: PropTypes.func,
    width: PropTypes.string,
    height: PropTypes.string,
    parentNode: PropTypes.string,
    configOverwrite: PropTypes.object,
    interfaceConfigOverwrite: PropTypes.object,
    noSSL: PropTypes.bool,
    jwt: PropTypes.string,
    onload: PropTypes.func,
    invitees: PropTypes.array,
    devices: PropTypes.object,
    userInfo: PropTypes.object
  })
};

var Jutsu = function Jutsu(_ref) {
  var loadingComponent = _ref.loadingComponent,
      errorComponent = _ref.errorComponent,
      containerStyles = _ref.containerStyles,
      jitsiContainerStyles = _ref.jitsiContainerStyles,
      onError = _ref.onError,
      onJitsi = _ref.onJitsi,
      options = objectWithoutProperties(_ref, ['loadingComponent', 'errorComponent', 'containerStyles', 'jitsiContainerStyles', 'onError', 'onJitsi']);

  var _useJitsi = useJitsi(_extends({
    parentNode: 'jitsi-container'
  }, options)),
      loading = _useJitsi.loading,
      error = _useJitsi.error,
      jitsi = _useJitsi.jitsi;

  useEffect(function () {
    if (jitsi && onJitsi) onJitsi(jitsi);
  }, [jitsi]);

  useEffect(function () {
    if (error && onError) onError(error);
  }, [error]);

  return React.createElement(
    'div',
    { style: _extends({ width: '800px', height: '400px' }, containerStyles) },
    error && (errorComponent || React.createElement(
      'p',
      null,
      error
    )),
    !error && loading && (loadingComponent || React.createElement(
      'p',
      null,
      'Loading ...'
    )),
    React.createElement('div', {
      id: 'jitsi-container',
      style: _extends({
        display: loading ? 'none' : 'block',
        width: '100%',
        height: '100%'
      }, jitsiContainerStyles)
    })
  );
};

Jutsu.propTypes = {
  jwt: PropTypes.string,
  domain: PropTypes.string,
  subject: PropTypes.string,
  password: PropTypes.string,
  roomName: PropTypes.string.isRequired,
  displayName: PropTypes.string,
  onMeetingEnd: PropTypes.func,
  loadingComponent: PropTypes.object,
  errorComponent: PropTypes.object,
  containerStyles: PropTypes.object,
  jitsiContainerStyles: PropTypes.object,
  configOverwrite: PropTypes.object,
  interfaceConfigOverwrite: PropTypes.object,
  onError: PropTypes.func,
  onJitsi: PropTypes.func
};

export { Jutsu, useJitsi };
//# sourceMappingURL=index.es.js.map
